(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	((function() {if (!global.chai) throw new Error("Chai cannot be found in current scope.");global.chai.use(factory());})());
}(this, (function () { 'use strict';

/*!
 * chai-spies :: a chai plugin
 * Copyright (c) 2012 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * We are going to export a function that can be used through chai
 */

var spy = function (chai, _) {
  // Easy access
  var Assertion = chai.Assertion
    , flag = _.flag
    , i = _.inspect
    , STATE_KEY = typeof Symbol === 'undefined' ? '__state' : Symbol('state')
    , spyAmount = 0
    , DEFAULT_SANDBOX = new Sandbox()
    , noop = function () {};

  /**
   * # Sandbox constructor (function)
   *
   * Initialize new Sandbox instance
   *
   * @returns new sandbox
   * @api private
   */

  function Sandbox() {
    this[STATE_KEY] = {};
  }

  /**
   * # Sandbox.on (function)
   *
   * Wraps an object method into spy assigned to sandbox. All calls will
   * pass through to the original function.
   *
   *      var spy = chai.spy.sandbox();
   *      var isArray = spy.on(Array, 'isArray');
   *
   *      const array = []
   *      const spy = chai.spy.sandbox();
   *      const [push, pop] = spy.on(array, ['push', 'pop']);
   *
   *      spy.on(array, 'push', returns => 1)
   *
   * @param {Object} object
   * @param {String|String[]} method name or methods names to spy on
   * @param {Function} [fn] mock implementation
   * @returns created spy or created spies
   * @api public
   */

  Sandbox.prototype.on = function (object, methodName, fn) {
    if (Array.isArray(methodName)) {
      return methodName.map(function (name) {
        return this.on(object, name, fn);
      }, this);
    }

    var isMethod = typeof object[methodName] === 'function';

    if (methodName in object && !isMethod) {
      throw new Error([
        'Unable to spy property "', methodName,
        '". Only methods and non-existing properties can be spied.'
      ].join(''))
    }

    if (isMethod && object[methodName].__spy) {
      throw new Error('"' + methodName + '" is already a spy')
    }

    var method = chai.spy('object.' + methodName, fn || object[methodName]);
    var trackingId = ++spyAmount;

    this[STATE_KEY][trackingId] = method;
    method.__spy.